/**
 * Docker Compose configuration generation
 * Generates docker-compose.yml for self-hosted deployments
 */

import { X402Config } from "../types/config.js";

/**
 * Docker Compose service configuration
 */
interface ComposeService {
  image?: string;
  build?: {
    context: string;
    dockerfile: string;
    target?: string;
    args?: Record<string, string>;
  };
  container_name?: string;
  restart?: string;
  ports?: string[];
  environment?: Record<string, string>;
  env_file?: string[];
  volumes?: string[];
  depends_on?: string[] | Record<string, { condition: string }>;
  networks?: string[];
  healthcheck?: {
    test: string[];
    interval: string;
    timeout: string;
    retries: number;
    start_period: string;
  };
  deploy?: {
    replicas?: number;
    resources?: {
      limits?: { cpus?: string; memory?: string };
      reservations?: { cpus?: string; memory?: string };
    };
  };
  labels?: Record<string, string>;
  logging?: {
    driver: string;
    options?: Record<string, string>;
  };
}

/**
 * Docker Compose configuration
 */
interface ComposeConfig {
  version: string;
  services: Record<string, ComposeService>;
  networks?: Record<string, { driver?: string; external?: boolean }>;
  volumes?: Record<string, { driver?: string }>;
}

/**
 * Generate docker-compose.yml for self-hosted deployment
 */
export function generateDockerCompose(config: X402Config): string {
  const appName = config.name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-")
    .replace(/-+/g, "-");

  const projectType = config.type || "unknown";
  const scaling = config.deploy?.scaling || { min: 1, max: 10 };

  const compose: ComposeConfig = {
    version: "3.8",
    services: {
      app: {
        build: {
          context: ".",
          dockerfile: "Dockerfile",
          target: "production",
        },
        container_name: `${appName}-app`,
        restart: "unless-stopped",
        ports: ["${PORT:-3000}:3000"],
        environment: {
          NODE_ENV: "production",
          PORT: "3000",
          X402_ENABLED: "true",
          X402_WALLET: config.payment.wallet,
          X402_NETWORK: config.payment.network,
          X402_TOKEN: config.payment.token || "USDC",
          X402_PRICING_MODEL: config.pricing.model,
          X402_DEFAULT_PRICE: config.pricing.default || "$0.001",
        },
        env_file: [".env"],
        networks: ["x402-network"],
        healthcheck: {
          test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"],
          interval: "30s",
          timeout: "5s",
          retries: 3,
          start_period: "10s",
        },
        deploy: {
          replicas: scaling.min,
          resources: {
            limits: {
              cpus: "1.0",
              memory: "512M",
            },
            reservations: {
              cpus: "0.25",
              memory: "128M",
            },
          },
        },
        labels: {
          "x402.enabled": "true",
          "x402.version": config.version,
          "traefik.enable": "true",
          [`traefik.http.routers.${appName}.rule`]: `Host(\`\${DOMAIN:-localhost}\`)`,
          [`traefik.http.routers.${appName}.tls`]: "true",
          [`traefik.http.routers.${appName}.tls.certresolver`]: "letsencrypt",
          [`traefik.http.services.${appName}.loadbalancer.server.port`]: "3000",
        },
        logging: {
          driver: "json-file",
          options: {
            "max-size": "10m",
            "max-file": "3",
          },
        },
      },
    },
    networks: {
      "x402-network": {
        driver: "bridge",
      },
    },
  };

  // Add facilitator if configured
  if (compose.services.app.environment && config.payment.facilitator) {
    compose.services.app.environment.X402_FACILITATOR_URL = config.payment.facilitator;
  }

  // Convert to YAML
  return convertToYaml(compose, appName);
}

/**
 * Convert compose config to YAML string
 */
function convertToYaml(config: ComposeConfig, appName: string): string {
  const app = config.services.app;

  return `# Auto-generated by x402-deploy
# Project: ${appName}
# Self-hosted Docker Compose configuration

version: "${config.version}"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: ${app.container_name}
    restart: ${app.restart}
    ports:
      - "\${PORT:-3000}:3000"
    environment:
${Object.entries(app.environment || {})
  .map(([key, value]) => `      ${key}: "${value}"`)
  .join("\n")}
    env_file:
      - .env
    networks:
      - x402-network
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    deploy:
      replicas: ${app.deploy?.replicas || 1}
      resources:
        limits:
          cpus: "1.0"
          memory: 512M
        reservations:
          cpus: "0.25"
          memory: 128M
    labels:
      - "x402.enabled=true"
      - "x402.version=${app.labels?.["x402.version"] || "1.0.0"}"
      # Traefik labels for automatic HTTPS
      - "traefik.enable=true"
      - "traefik.http.routers.${appName}.rule=Host(\`\${DOMAIN:-localhost}\`)"
      - "traefik.http.routers.${appName}.tls=true"
      - "traefik.http.routers.${appName}.tls.certresolver=letsencrypt"
      - "traefik.http.services.${appName}.loadbalancer.server.port=3000"
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

networks:
  x402-network:
    driver: bridge
`;
}

/**
 * Generate full stack docker-compose with Traefik, Prometheus, etc.
 */
export function generateFullStackCompose(config: X402Config): string {
  const appName = config.name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-")
    .replace(/-+/g, "-");

  return `# Auto-generated by x402-deploy
# Full-stack self-hosted deployment with reverse proxy, monitoring, and SSL

version: "3.8"

services:
  # ========== Reverse Proxy (Traefik) ==========
  traefik:
    image: traefik:v2.10
    container_name: ${appName}-traefik
    restart: unless-stopped
    command:
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencrypt.acme.email=\${ACME_EMAIL:-admin@example.com}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--metrics.prometheus=true"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "traefik-certs:/letsencrypt"
    networks:
      - x402-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(\`traefik.\${DOMAIN:-localhost}\`)"
      - "traefik.http.routers.dashboard.service=api@internal"
      - "traefik.http.routers.dashboard.middlewares=auth"
      - "traefik.http.middlewares.auth.basicauth.users=\${TRAEFIK_AUTH:-admin:$$apr1$$xyz$$hash}"

  # ========== Application ==========
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: ${appName}-app
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: "3000"
      X402_ENABLED: "true"
      X402_WALLET: "${config.payment.wallet}"
      X402_NETWORK: "${config.payment.network}"
      X402_TOKEN: "${config.payment.token || "USDC"}"
      X402_PRICING_MODEL: "${config.pricing.model}"
      X402_DEFAULT_PRICE: "${config.pricing.default || "$0.001"}"
    env_file:
      - .env
    networks:
      - x402-network
    depends_on:
      - traefik
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    deploy:
      replicas: \${REPLICAS:-1}
      resources:
        limits:
          cpus: "1.0"
          memory: 512M
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.${appName}.rule=Host(\`\${DOMAIN:-localhost}\`)"
      - "traefik.http.routers.${appName}.tls=true"
      - "traefik.http.routers.${appName}.tls.certresolver=letsencrypt"
      - "traefik.http.services.${appName}.loadbalancer.server.port=3000"

  # ========== Monitoring (Prometheus) ==========
  prometheus:
    image: prom/prometheus:v2.47.0
    container_name: ${appName}-prometheus
    restart: unless-stopped
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--storage.tsdb.path=/prometheus"
      - "--storage.tsdb.retention.time=15d"
    volumes:
      - "./prometheus.yml:/etc/prometheus/prometheus.yml:ro"
      - "prometheus-data:/prometheus"
    networks:
      - x402-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus.rule=Host(\`prometheus.\${DOMAIN:-localhost}\`)"
      - "traefik.http.routers.prometheus.tls=true"
      - "traefik.http.routers.prometheus.middlewares=auth"
      - "traefik.http.services.prometheus.loadbalancer.server.port=9090"

  # ========== Visualization (Grafana) ==========
  grafana:
    image: grafana/grafana:10.1.0
    container_name: ${appName}-grafana
    restart: unless-stopped
    environment:
      GF_SECURITY_ADMIN_USER: \${GRAFANA_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: \${GRAFANA_PASSWORD:-admin}
      GF_USERS_ALLOW_SIGN_UP: "false"
    volumes:
      - "grafana-data:/var/lib/grafana"
    networks:
      - x402-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(\`grafana.\${DOMAIN:-localhost}\`)"
      - "traefik.http.routers.grafana.tls=true"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"

networks:
  x402-network:
    driver: bridge

volumes:
  traefik-certs:
  prometheus-data:
  grafana-data:
`;
}

/**
 * Generate .env.example for self-hosted deployment
 */
export function generateEnvExample(config: X402Config): string {
  return `# Auto-generated by x402-deploy
# Copy this file to .env and fill in your values

# ========== Required ==========
# Domain for your deployment
DOMAIN=api.yourdomain.com

# Email for Let's Encrypt SSL certificates
ACME_EMAIL=admin@yourdomain.com

# ========== x402 Configuration ==========
# Your wallet address for receiving payments
X402_WALLET=${config.payment.wallet}

# Blockchain network (CAIP-2 format)
X402_NETWORK=${config.payment.network}

# Payment token (default: USDC)
X402_TOKEN=${config.payment.token || "USDC"}

# Facilitator URL (optional, uses default if not set)
X402_FACILITATOR_URL=${config.payment.facilitator || ""}

# ========== Optional ==========
# Number of replicas
REPLICAS=1

# Port (default: 3000)
PORT=3000

# Traefik dashboard auth (htpasswd format)
# Generate with: htpasswd -nb admin your-password
TRAEFIK_AUTH=

# Grafana credentials
GRAFANA_USER=admin
GRAFANA_PASSWORD=

# ========== Secrets ==========
# Add any API keys or secrets below
# API_KEY=
# DATABASE_URL=
`;
}

/**
 * Generate prometheus.yml for monitoring
 */
export function generatePrometheusConfig(config: X402Config): string {
  const appName = config.name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-")
    .replace(/-+/g, "-");

  return `# Auto-generated by x402-deploy
# Prometheus configuration for x402 monitoring

global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # Prometheus self-monitoring
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Traefik metrics
  - job_name: 'traefik'
    static_configs:
      - targets: ['traefik:8080']

  # Application metrics
  - job_name: '${appName}'
    static_configs:
      - targets: ['app:3000']
    metrics_path: '/metrics'

  # x402 payment metrics (if available)
  - job_name: 'x402-payments'
    static_configs:
      - targets: ['app:3000']
    metrics_path: '/.well-known/x402/metrics'
`;
}
