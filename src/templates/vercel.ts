/**
 * Vercel deployment configuration generation
 * Generates vercel.json for Next.js and other projects
 */

import { X402Config } from "../types/config.js";

/**
 * Vercel configuration interface
 */
export interface VercelConfig {
  $schema: string;
  name?: string;
  version?: number;
  framework?: string;
  buildCommand?: string;
  installCommand?: string;
  outputDirectory?: string;
  public?: boolean;
  cleanUrls?: boolean;
  trailingSlash?: boolean;
  env?: Record<string, string>;
  build?: {
    env?: Record<string, string>;
  };
  functions?: Record<string, {
    memory?: number;
    maxDuration?: number;
    runtime?: string;
  }>;
  regions?: string[];
  rewrites?: Array<{
    source: string;
    destination: string;
  }>;
  redirects?: Array<{
    source: string;
    destination: string;
    permanent?: boolean;
    statusCode?: number;
  }>;
  headers?: Array<{
    source: string;
    headers: Array<{
      key: string;
      value: string;
    }>;
  }>;
  crons?: Array<{
    path: string;
    schedule: string;
  }>;
}

/**
 * Vercel edge regions
 */
export const VERCEL_REGIONS = {
  "arn1": "Stockholm, Sweden",
  "bom1": "Mumbai, India",
  "cdg1": "Paris, France",
  "cle1": "Cleveland, USA",
  "cpt1": "Cape Town, South Africa",
  "dub1": "Dublin, Ireland",
  "fra1": "Frankfurt, Germany",
  "gru1": "SÃ£o Paulo, Brazil",
  "hkg1": "Hong Kong",
  "hnd1": "Tokyo, Japan",
  "iad1": "Washington, D.C., USA",
  "icn1": "Seoul, South Korea",
  "kix1": "Osaka, Japan",
  "lhr1": "London, UK",
  "pdx1": "Portland, USA",
  "sfo1": "San Francisco, USA",
  "sin1": "Singapore",
  "syd1": "Sydney, Australia",
} as const;

export type VercelRegion = keyof typeof VERCEL_REGIONS;

/**
 * Generate vercel.json configuration
 */
export function generateVercelJson(config: X402Config): string {
  const projectType = config.type || "unknown";
  const isNextJs = projectType === "nextjs";

  const vercelConfig: VercelConfig = {
    $schema: "https://openapi.vercel.sh/vercel.json",
    name: config.name.toLowerCase().replace(/[^a-z0-9-]/g, "-"),
    version: 2,
    cleanUrls: true,
    trailingSlash: false,
    env: {
      NODE_ENV: "production",
      X402_ENABLED: "true",
      X402_WALLET: config.payment.wallet,
      X402_NETWORK: config.payment.network,
      X402_TOKEN: config.payment.token || "USDC",
      X402_PRICING_MODEL: config.pricing.model,
      X402_DEFAULT_PRICE: config.pricing.default || "$0.001",
    },
    headers: [
      {
        source: "/api/(.*)",
        headers: [
          { key: "X-X402-Enabled", value: "true" },
          { key: "Access-Control-Allow-Origin", value: "*" },
          { key: "Access-Control-Allow-Methods", value: "GET, POST, PUT, DELETE, OPTIONS" },
          { key: "Access-Control-Allow-Headers", value: "Content-Type, Authorization, X-Payment, X-Payment-Response" },
          { key: "Access-Control-Expose-Headers", value: "X-Payment-Required, X-Payment-Accepts" },
        ],
      },
      {
        source: "/.well-known/x402/(.*)",
        headers: [
          { key: "Content-Type", value: "application/json" },
          { key: "Cache-Control", value: "public, max-age=3600" },
        ],
      },
    ],
  };

  // Add Next.js specific settings
  if (isNextJs) {
    vercelConfig.framework = "nextjs";
    vercelConfig.functions = {
      "api/**/*.ts": {
        memory: 1024,
        maxDuration: 30,
      },
    };
  }

  // Add regions if specified
  if (config.deploy?.region) {
    const regionMap: Record<string, VercelRegion[]> = {
      "us-east": ["iad1"],
      "us-west": ["sfo1", "pdx1"],
      "eu-west": ["lhr1", "dub1"],
      "eu-central": ["fra1"],
      "ap-northeast": ["hnd1", "icn1"],
      "ap-southeast": ["sin1", "syd1"],
    };
    if (config.deploy.region in regionMap) {
      vercelConfig.regions = regionMap[config.deploy.region];
    }
  }

  // Add facilitator URL if configured
  if (config.payment.facilitator && vercelConfig.env) {
    vercelConfig.env.X402_FACILITATOR_URL = config.payment.facilitator;
  }

  // Add discovery settings
  if (config.discovery?.enabled !== false && vercelConfig.env) {
    vercelConfig.env.X402_DISCOVERY_ENABLED = "true";
  }

  return JSON.stringify(vercelConfig, null, 2);
}

/**
 * Generate Next.js middleware for x402 payments
 */
export function generateNextMiddleware(config: X402Config): string {
  return `// Auto-generated by x402-deploy
// Next.js middleware for x402 payment integration

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// Route pricing configuration
const ROUTE_PRICING: Record<string, string> = ${JSON.stringify(config.pricing.routes || {}, null, 2)};

const DEFAULT_PRICE = "${config.pricing.default || "$0.001"}";

/**
 * Check if a route requires payment
 */
function getRoutePrice(pathname: string): string | null {
  // Check exact match first
  if (ROUTE_PRICING[pathname]) {
    const pricing = ROUTE_PRICING[pathname];
    return typeof pricing === 'string' ? pricing : pricing.price;
  }
  
  // Check pattern matches
  for (const [pattern, pricing] of Object.entries(ROUTE_PRICING)) {
    if (pattern.includes('*')) {
      const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');
      if (regex.test(pathname)) {
        return typeof pricing === 'string' ? pricing : pricing.price;
      }
    }
  }
  
  // Return default for API routes
  if (pathname.startsWith('/api/')) {
    return DEFAULT_PRICE;
  }
  
  return null;
}

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Skip non-API routes and public endpoints
  if (!pathname.startsWith('/api/') || pathname === '/api/health') {
    return NextResponse.next();
  }
  
  // Check for payment header
  const paymentHeader = request.headers.get('X-Payment');
  const price = getRoutePrice(pathname);
  
  if (price && !paymentHeader) {
    // Return 402 Payment Required
    return new NextResponse(
      JSON.stringify({
        error: "Payment Required",
        message: "This endpoint requires payment via x402 protocol",
        x402: {
          version: "1.0",
          price: price,
          network: "${config.payment.network}",
          token: "${config.payment.token || "USDC"}",
          wallet: "${config.payment.wallet}",
        },
      }),
      {
        status: 402,
        headers: {
          'Content-Type': 'application/json',
          'X-Payment-Required': 'true',
          'X-Payment-Accepts': 'x402',
        },
      }
    );
  }
  
  // Verify payment with facilitator
  const facilitatorUrl = process.env.X402_FACILITATOR_URL || 'https://facilitator.x402.dev';
  
  try {
    const paymentData = JSON.parse(Buffer.from(paymentHeader, 'base64').toString());
    
    const verifyResponse = await fetch(\`\${facilitatorUrl}/verify\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        payment: paymentData,
        expectedPrice: price,
        expectedPayTo: config.payment.wallet,
        network: config.payment.network,
      }),
    });

    if (!verifyResponse.ok) {
      const error = await verifyResponse.json();
      return new Response(
        JSON.stringify({
          error: 'payment_invalid',
          message: error.message || 'Payment verification failed',
        }),
        { status: 402, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const verification = await verifyResponse.json();
    if (!verification.valid) {
      return new Response(
        JSON.stringify({
          error: 'payment_invalid',
          message: verification.error || 'Payment invalid',
        }),
        { status: 402, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Payment verified - add payer info to headers and continue
    const response = NextResponse.next();
    response.headers.set('x-payment-verified', 'true');
    response.headers.set('x-payer-address', verification.payer || '');
    response.headers.set('x-payment-amount', verification.amount || '');
    return response;
  } catch (error) {
    console.error('[x402] Payment verification error:', error);
    return NextResponse.next();
  }
}

export const config = {
  matcher: '/api/:path*',
};
`;
}

/**
 * Generate Next.js API route wrapper
 */
export function generateNextApiWrapper(config: X402Config): string {
  return `// Auto-generated by x402-deploy
// Next.js API route wrapper for x402 payment verification

import { NextRequest, NextResponse } from 'next/server';

interface X402VerifyResult {
  valid: boolean;
  payer?: string;
  amount?: string;
  error?: string;
}

/**
 * Verify x402 payment header
 */
async function verifyPayment(
  paymentHeader: string,
  expectedAmount: string
): Promise<X402VerifyResult> {
  const facilitatorUrl = process.env.X402_FACILITATOR_URL || "https://facilitator.x402.org";
  
  try {
    const response = await fetch(\`\${facilitatorUrl}/verify\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        payment: paymentHeader,
        expectedAmount,
        wallet: process.env.X402_WALLET || "${config.payment.wallet}",
        network: process.env.X402_NETWORK || "${config.payment.network}",
      }),
    });
    
    if (!response.ok) {
      return { valid: false, error: 'Facilitator verification failed' };
    }
    
    return await response.json();
  } catch (error) {
    console.error('Payment verification error:', error);
    return { valid: false, error: 'Payment verification failed' };
  }
}

/**
 * Wrap an API handler with x402 payment verification
 */
export function withX402<T>(
  handler: (req: NextRequest) => Promise<NextResponse<T>>,
  options: { price: string }
) {
  return async (req: NextRequest): Promise<NextResponse> => {
    const paymentHeader = req.headers.get('X-Payment');
    
    if (!paymentHeader) {
      return NextResponse.json(
        {
          error: "Payment Required",
          x402: {
            version: "1.0",
            price: options.price,
            network: process.env.X402_NETWORK || "${config.payment.network}",
            token: process.env.X402_TOKEN || "${config.payment.token || "USDC"}",
            wallet: process.env.X402_WALLET || "${config.payment.wallet}",
          },
        },
        { status: 402 }
      );
    }
    
    const verification = await verifyPayment(paymentHeader, options.price);
    
    if (!verification.valid) {
      return NextResponse.json(
        { error: "Payment verification failed", details: verification.error },
        { status: 402 }
      );
    }
    
    // Payment verified, proceed with handler
    return handler(req);
  };
}
`;
}

/**
 * Generate environment variable configuration for Vercel
 */
export function generateVercelEnvs(config: X402Config): Array<{
  key: string;
  value: string;
  target: ("production" | "preview" | "development")[];
}> {
  const envs = [
    { key: "X402_ENABLED", value: "true", target: ["production", "preview"] as const },
    { key: "X402_WALLET", value: config.payment.wallet, target: ["production", "preview"] as const },
    { key: "X402_NETWORK", value: config.payment.network, target: ["production", "preview"] as const },
    { key: "X402_TOKEN", value: config.payment.token || "USDC", target: ["production", "preview"] as const },
    { key: "X402_PRICING_MODEL", value: config.pricing.model, target: ["production", "preview"] as const },
    { key: "X402_DEFAULT_PRICE", value: config.pricing.default || "$0.001", target: ["production", "preview"] as const },
  ];

  if (config.payment.facilitator) {
    envs.push({
      key: "X402_FACILITATOR_URL",
      value: config.payment.facilitator,
      target: ["production", "preview"] as const,
    });
  }

  return envs.map(e => ({ ...e, target: [...e.target] }));
}
