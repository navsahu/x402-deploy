/**
 * Wrapper code generation for x402 payment integration
 * Generates runtime wrappers that intercept requests and handle payments
 */

import { X402Config, ProjectType } from "../types/config.js";

/**
 * Generate the main wrapper.js for Node.js projects
 */
export function generateNodeWrapper(config: X402Config): string {
  const projectType = config.type || "unknown";

  return `// Auto-generated by x402-deploy
// x402 Payment Wrapper for Node.js
// Project: ${config.name}
// Type: ${projectType}

import express from 'express';
import { createServer as createHttpServer } from 'http';

// Configuration
const config = ${JSON.stringify(config, null, 2)};

// Route pricing
const ROUTE_PRICING = ${JSON.stringify(config.pricing.routes || {}, null, 2)};
const DEFAULT_PRICE = "${config.pricing.default || "$0.001"}";

// Facilitator URL
const FACILITATOR_URL = process.env.X402_FACILITATOR_URL || "${config.payment.facilitator || "https://facilitator.x402.org"}";

// Metrics tracking
const metrics = {
  requests: 0,
  payments: 0,
  revenue: 0,
  startedAt: Date.now(),
  payerAddresses: new Set(),
  routeStats: new Map(),
};

/**
 * Track a request
 */
function trackRequest(route, payer, amount) {
  metrics.requests++;
  if (payer && amount) {
    metrics.payments++;
    const cents = parsePriceToCents(amount);
    metrics.revenue += cents;
    metrics.payerAddresses.add(payer);
    
    const routeStat = metrics.routeStats.get(route) || { requests: 0, revenue: 0 };
    routeStat.requests++;
    routeStat.revenue += cents;
    metrics.routeStats.set(route, routeStat);
  }
}

/**
 * Get formatted metrics
 */
function getMetrics() {
  return {
    requests: metrics.requests,
    payments: metrics.payments,
    revenue: '$' + (metrics.revenue / 100).toFixed(2),
    uniquePayers: metrics.payerAddresses.size,
    uptime: Math.floor((Date.now() - metrics.startedAt) / 1000),
    routeStats: Object.fromEntries(
      Array.from(metrics.routeStats.entries()).map(([route, stats]) => [
        route,
        { requests: stats.requests, revenue: '$' + (stats.revenue / 100).toFixed(2) }
      ])
    ),
  };
}

/**
 * Parse price string to cents
 */
function parsePriceToCents(priceStr) {
  if (!priceStr) return 0;
  const match = priceStr.match(/\\$?([\\d.]+)/);
  if (!match) return 0;
  return Math.round(parseFloat(match[1]) * 100);
}

/**
 * Get price for a route
 */
function getRoutePrice(path) {
  // Check exact match
  if (ROUTE_PRICING[path]) {
    const pricing = ROUTE_PRICING[path];
    return typeof pricing === 'string' ? pricing : pricing.price;
  }
  
  // Check pattern matches
  for (const [pattern, pricing] of Object.entries(ROUTE_PRICING)) {
    if (pattern.includes('*')) {
      const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');
      if (regex.test(path)) {
        return typeof pricing === 'string' ? pricing : pricing.price;
      }
    }
  }
  
  return DEFAULT_PRICE;
}

/**
 * Verify payment with facilitator
 */
async function verifyPayment(paymentHeader, expectedAmount) {
  try {
    const response = await fetch(\`\${FACILITATOR_URL}/verify\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        payment: paymentHeader,
        expectedAmount,
        wallet: config.payment.wallet,
        network: config.payment.network,
      }),
    });
    
    if (!response.ok) {
      return { valid: false, error: 'Facilitator verification failed' };
    }
    
    return await response.json();
  } catch (error) {
    console.error('[x402] Payment verification error:', error.message);
    return { valid: false, error: error.message };
  }
}

/**
 * x402 payment middleware
 */
function x402Middleware(req, res, next) {
  // Skip health checks and discovery endpoints
  if (req.path === '/health' || req.path.startsWith('/.well-known/x402')) {
    return next();
  }
  
  const price = getRoutePrice(req.path);
  
  // If no price or free, continue
  if (!price || price === '$0' || price === '0') {
    return next();
  }
  
  const paymentHeader = req.headers['x-payment'];
  
  if (!paymentHeader) {
    // Return 402 Payment Required
    return res.status(402).json({
      error: 'Payment Required',
      message: 'This endpoint requires payment via x402 protocol',
      x402: {
        version: '1.0',
        price: price,
        network: config.payment.network,
        token: config.payment.token || 'USDC',
        wallet: config.payment.wallet,
        facilitator: FACILITATOR_URL,
      },
    });
  }
  
  // Verify payment asynchronously
  verifyPayment(paymentHeader, price)
    .then(result => {
      if (!result.valid) {
        return res.status(402).json({
          error: 'Payment verification failed',
          details: result.error,
        });
      }
      
      // Track the successful payment
      trackRequest(req.path, result.payer, result.amount || price);
      
      // Payment verified, add info to request
      req.x402 = {
        verified: true,
        payer: result.payer,
        amount: result.amount,
        txHash: result.txHash,
      };
      
      next();
    })
    .catch(error => {
      console.error('[x402] Payment error:', error);
      res.status(500).json({ error: 'Payment processing error' });
    });
}

/**
 * Discovery endpoints
 */
function setupDiscoveryEndpoints(app) {
  // x402 discovery document
  app.get('/.well-known/x402/config', (req, res) => {
    res.json({
      version: '1.0',
      name: config.name,
      description: config.description,
      payment: {
        wallet: config.payment.wallet,
        network: config.payment.network,
        token: config.payment.token || 'USDC',
        facilitator: FACILITATOR_URL,
      },
      pricing: {
        model: config.pricing.model,
        default: config.pricing.default,
        routes: config.pricing.routes,
      },
    });
  });
  
  // Health check
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      service: config.name,
      x402: true,
      timestamp: new Date().toISOString(),
    });
  });
  
  // Metrics endpoint (if enabled)
  if (config.analytics?.enabled !== false) {
    app.get('/.well-known/x402/metrics', (req, res) => {
      res.json(getMetrics());
    });
  }
}

/**
 * Main entry point
 */
async function main() {
  const port = process.env.PORT || 3000;
  
  // Create Express app for x402 wrapper
  const wrapperApp = express();
  
  // Setup discovery endpoints first
  setupDiscoveryEndpoints(wrapperApp);
  
  // Apply x402 middleware
  wrapperApp.use(x402Middleware);
  
  try {
    // Dynamic import of user's application
    const userApp = await import('../dist/index.js');
    
    // Mount user's app or handler
    if (typeof userApp.default === 'function') {
      // Express app or handler function
      wrapperApp.use(userApp.default);
    } else if (userApp.createServer) {
      // MCP server or custom server factory
      const server = await userApp.createServer();
      if (typeof server === 'function') {
        wrapperApp.use(server);
      } else if (server.app) {
        wrapperApp.use(server.app);
      }
    } else if (userApp.app) {
      wrapperApp.use(userApp.app);
    } else {
      console.warn('[x402] Could not find app export, using wrapper only');
    }
  } catch (error) {
    console.error('[x402] Failed to load user application:', error.message);
    console.log('[x402] Running in discovery-only mode');
  }
  
  // Start server
  const server = createHttpServer(wrapperApp);
  
  server.listen(port, () => {
    console.log('');
    console.log('╔════════════════════════════════════════════════════════╗');
    console.log('║                    x402-deploy                         ║');
    console.log('╠════════════════════════════════════════════════════════╣');
    console.log(\`║  Service: \${config.name.padEnd(43)}║\`);
    console.log(\`║  Port:    \${String(port).padEnd(43)}║\`);
    console.log(\`║  Network: \${config.payment.network.padEnd(43)}║\`);
    console.log(\`║  Wallet:  \${config.payment.wallet.substring(0, 20)}...\${' '.repeat(20)}║\`);
    console.log('╠════════════════════════════════════════════════════════╣');
    console.log('║  Endpoints:                                            ║');
    console.log(\`║    Health:    http://localhost:\${port}/health\${' '.repeat(21 - String(port).length)}║\`);
    console.log(\`║    Discovery: http://localhost:\${port}/.well-known/x402/config\${' '.repeat(3 - String(port).length)}║\`);
    console.log('╚════════════════════════════════════════════════════════╝');
    console.log('');
  });
  
  // Graceful shutdown
  process.on('SIGTERM', () => {
    console.log('[x402] Received SIGTERM, shutting down gracefully...');
    server.close(() => {
      console.log('[x402] Server closed');
      process.exit(0);
    });
  });
}

main().catch(error => {
  console.error('[x402] Fatal error:', error);
  process.exit(1);
});
`;
}

/**
 * Generate Python wrapper for FastAPI projects
 */
export function generatePythonWrapper(config: X402Config): string {
  return `# Auto-generated by x402-deploy
# x402 Payment Wrapper for Python/FastAPI
# Project: ${config.name}

import os
import re
import json
import asyncio
from typing import Optional, Dict, Any
from datetime import datetime
import httpx
from fastapi import FastAPI, Request, Response, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware

# Configuration
CONFIG = ${JSON.stringify(config, null, 2)}

# Route pricing
ROUTE_PRICING: Dict[str, Any] = ${JSON.stringify(config.pricing.routes || {}, null, 2)}
DEFAULT_PRICE = "${config.pricing.default || "$0.001"}"

# Facilitator URL
FACILITATOR_URL = os.environ.get(
    "X402_FACILITATOR_URL",
    "${config.payment.facilitator || "https://facilitator.x402.org"}"
)

# Metrics tracking
class Metrics:
    def __init__(self):
        self.requests = 0
        self.payments = 0
        self.revenue_cents = 0
        self.started_at = datetime.utcnow()
        self.payer_addresses: set = set()
        self.route_stats: Dict[str, Dict[str, int]] = {}
    
    def track_request(self, route: str, payer: Optional[str] = None, amount: Optional[str] = None):
        self.requests += 1
        if payer and amount:
            self.payments += 1
            cents = self._parse_price(amount)
            self.revenue_cents += cents
            self.payer_addresses.add(payer)
            
            if route not in self.route_stats:
                self.route_stats[route] = {"requests": 0, "revenue": 0}
            self.route_stats[route]["requests"] += 1
            self.route_stats[route]["revenue"] += cents
    
    def _parse_price(self, price_str: str) -> int:
        if not price_str:
            return 0
        import re
        match = re.match(r"\\$?([\\d.]+)", price_str)
        if not match:
            return 0
        return int(float(match.group(1)) * 100)
    
    def to_dict(self) -> Dict[str, Any]:
        uptime = (datetime.utcnow() - self.started_at).total_seconds()
        return {
            "requests": self.requests,
            "payments": self.payments,
            "revenue": f"${self.revenue_cents / 100:.2f}",
            "uniquePayers": len(self.payer_addresses),
            "uptime": int(uptime),
            "routeStats": {
                route: {"requests": stats["requests"], "revenue": f"${stats['revenue'] / 100:.2f}"}
                for route, stats in self.route_stats.items()
            },
        }

metrics = Metrics()


def get_route_price(path: str) -> Optional[str]:
    """Get price for a route."""
    # Check exact match
    if path in ROUTE_PRICING:
        pricing = ROUTE_PRICING[path]
        return pricing if isinstance(pricing, str) else pricing.get("price")
    
    # Check pattern matches
    for pattern, pricing in ROUTE_PRICING.items():
        if "*" in pattern:
            regex = "^" + pattern.replace("*", ".*") + "$"
            if re.match(regex, path):
                return pricing if isinstance(pricing, str) else pricing.get("price")
    
    return DEFAULT_PRICE


async def verify_payment(payment_header: str, expected_amount: str) -> Dict[str, Any]:
    """Verify payment with facilitator."""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{FACILITATOR_URL}/verify",
                json={
                    "payment": payment_header,
                    "expectedAmount": expected_amount,
                    "wallet": CONFIG["payment"]["wallet"],
                    "network": CONFIG["payment"]["network"],
                },
                timeout=10.0,
            )
            
            if response.status_code != 200:
                return {"valid": False, "error": "Facilitator verification failed"}
            
            return response.json()
    except Exception as e:
        print(f"[x402] Payment verification error: {e}")
        return {"valid": False, "error": str(e)}


class X402Middleware(BaseHTTPMiddleware):
    """x402 payment middleware."""
    
    async def dispatch(self, request: Request, call_next) -> Response:
        path = request.url.path
        
        # Skip health checks and discovery endpoints
        if path == "/health" or path.startswith("/.well-known/x402"):
            return await call_next(request)
        
        price = get_route_price(path)
        
        # If no price or free, continue
        if not price or price in ("$0", "0"):
            return await call_next(request)
        
        payment_header = request.headers.get("x-payment")
        
        if not payment_header:
            return JSONResponse(
                status_code=402,
                content={
                    "error": "Payment Required",
                    "message": "This endpoint requires payment via x402 protocol",
                    "x402": {
                        "version": "1.0",
                        "price": price,
                        "network": CONFIG["payment"]["network"],
                        "token": CONFIG["payment"].get("token", "USDC"),
                        "wallet": CONFIG["payment"]["wallet"],
                        "facilitator": FACILITATOR_URL,
                    },
                },
            )
        
        # Verify payment
        result = await verify_payment(payment_header, price)
        
        if not result.get("valid"):
            return JSONResponse(
                status_code=402,
                content={
                    "error": "Payment verification failed",
                    "details": result.get("error"),
                },
            )
        
        # Track the successful payment
        metrics.track_request(path, result.get("payer"), result.get("amount") or price)
        
        # Payment verified, add info to request state
        request.state.x402 = {
            "verified": True,
            "payer": result.get("payer"),
            "amount": result.get("amount"),
            "txHash": result.get("txHash"),
        }
        
        return await call_next(request)


# Create wrapper app
app = FastAPI(title=f"{CONFIG['name']} (x402-enabled)")


# Add x402 middleware
app.add_middleware(X402Middleware)


# Discovery endpoints
@app.get("/.well-known/x402/config")
async def x402_config():
    """x402 discovery document."""
    return {
        "version": "1.0",
        "name": CONFIG["name"],
        "description": CONFIG.get("description"),
        "payment": {
            "wallet": CONFIG["payment"]["wallet"],
            "network": CONFIG["payment"]["network"],
            "token": CONFIG["payment"].get("token", "USDC"),
            "facilitator": FACILITATOR_URL,
        },
        "pricing": {
            "model": CONFIG["pricing"]["model"],
            "default": CONFIG["pricing"].get("default"),
            "routes": CONFIG["pricing"].get("routes"),
        },
    }


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": CONFIG["name"],
        "x402": True,
        "timestamp": datetime.utcnow().isoformat(),
    }


@app.get("/.well-known/x402/metrics")
async def x402_metrics():
    """x402 metrics endpoint."""
    return metrics.to_dict()


# Import and mount user's FastAPI app
try:
    from main import app as user_app
    app.mount("/", user_app)
except ImportError:
    try:
        from app import app as user_app
        app.mount("/", user_app)
    except ImportError:
        print("[x402] Could not find user app, running in discovery-only mode")


if __name__ == "__main__":
    import uvicorn
    
    port = int(os.environ.get("PORT", 3000))
    
    print("")
    print("╔════════════════════════════════════════════════════════╗")
    print("║                    x402-deploy                         ║")
    print("╠════════════════════════════════════════════════════════╣")
    print(f"║  Service: {CONFIG['name']:<43}║")
    print(f"║  Port:    {port:<43}║")
    print(f"║  Network: {CONFIG['payment']['network']:<43}║")
    print(f"║  Wallet:  {CONFIG['payment']['wallet'][:20]}...{' ' * 20}║")
    print("╚════════════════════════════════════════════════════════╝")
    print("")
    
    uvicorn.run(app, host="0.0.0.0", port=port)
`;
}

/**
 * Generate package.json additions for x402 wrapper
 */
export function generateWrapperPackageAdditions(config: X402Config): Record<string, unknown> {
  return {
    scripts: {
      "x402:start": "node .x402/wrapper.js",
      "x402:dev": "nodemon .x402/wrapper.js",
    },
    dependencies: {
      "express": "^4.18.0",
    },
  };
}

/**
 * Generate MCP-specific wrapper for MCP servers
 */
export function generateMcpWrapper(config: X402Config): string {
  return `// Auto-generated by x402-deploy
// x402 Payment Wrapper for MCP Servers
// Project: ${config.name}

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import express from 'express';

// Configuration
const config = ${JSON.stringify(config, null, 2)};

// Tool pricing
const TOOL_PRICING = ${JSON.stringify(config.pricing.routes || {}, null, 2)};
const DEFAULT_PRICE = "${config.pricing.default || "$0.001"}";

// Facilitator URL
const FACILITATOR_URL = process.env.X402_FACILITATOR_URL || "${config.payment.facilitator || "https://facilitator.x402.org"}";

/**
 * Get price for a tool
 */
function getToolPrice(toolName) {
  if (TOOL_PRICING[toolName]) {
    const pricing = TOOL_PRICING[toolName];
    return typeof pricing === 'string' ? pricing : pricing.price;
  }
  return DEFAULT_PRICE;
}

/**
 * Verify payment with facilitator
 */
async function verifyPayment(paymentHeader, expectedAmount) {
  try {
    const response = await fetch(\`\${FACILITATOR_URL}/verify\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        payment: paymentHeader,
        expectedAmount,
        wallet: config.payment.wallet,
        network: config.payment.network,
      }),
    });
    
    if (!response.ok) {
      return { valid: false, error: 'Facilitator verification failed' };
    }
    
    return await response.json();
  } catch (error) {
    console.error('[x402] Payment verification error:', error.message);
    return { valid: false, error: error.message };
  }
}

/**
 * Create x402-wrapped MCP server
 */
async function createWrappedServer() {
  // Import user's MCP server
  const userModule = await import('../dist/index.js');
  
  let server;
  if (userModule.createServer) {
    server = await userModule.createServer();
  } else if (userModule.server) {
    server = userModule.server;
  } else if (userModule.default) {
    server = typeof userModule.default === 'function' 
      ? await userModule.default()
      : userModule.default;
  }
  
  if (!server) {
    throw new Error('Could not find MCP server export');
  }
  
  // Wrap tool handlers with payment verification
  const originalToolHandler = server.toolHandler;
  
  if (originalToolHandler) {
    server.toolHandler = async (request, extra) => {
      const toolName = request.params?.name;
      const price = getToolPrice(toolName);
      
      // Check for payment in request metadata
      const payment = extra?.payment || request.params?._payment;
      
      if (price && price !== '$0' && !payment) {
        throw {
          code: 402,
          message: 'Payment Required',
          data: {
            x402: {
              version: '1.0',
              tool: toolName,
              price: price,
              network: config.payment.network,
              token: config.payment.token || 'USDC',
              wallet: config.payment.wallet,
            },
          },
        };
      }
      
      if (payment) {
        const result = await verifyPayment(payment, price);
        if (!result.valid) {
          throw {
            code: 402,
            message: 'Payment verification failed',
            data: { error: result.error },
          };
        }
      }
      
      return originalToolHandler(request, extra);
    };
  }
  
  return server;
}

/**
 * HTTP server for SSE transport with x402
 */
async function startHttpServer() {
  const port = process.env.PORT || 3000;
  const app = express();
  
  // Health check
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      service: config.name,
      x402: true,
      transport: 'sse',
    });
  });
  
  // x402 discovery
  app.get('/.well-known/x402/config', (req, res) => {
    res.json({
      version: '1.0',
      name: config.name,
      type: 'mcp-server',
      payment: {
        wallet: config.payment.wallet,
        network: config.payment.network,
        token: config.payment.token || 'USDC',
      },
      pricing: {
        model: config.pricing.model,
        default: config.pricing.default,
        tools: config.pricing.routes,
      },
    });
  });
  
  // MCP SSE endpoint
  app.get('/sse', async (req, res) => {
    const server = await createWrappedServer();
    const transport = new SSEServerTransport('/message', res);
    await server.connect(transport);
  });
  
  app.listen(port, () => {
    console.log(\`[x402] MCP server running on port \${port}\`);
  });
}

/**
 * Main entry point
 */
async function main() {
  const transport = process.env.MCP_TRANSPORT || 'http';
  
  if (transport === 'stdio') {
    // STDIO transport (for local development)
    const server = await createWrappedServer();
    const stdioTransport = new StdioServerTransport();
    await server.connect(stdioTransport);
    console.error('[x402] MCP server running on stdio');
  } else {
    // HTTP/SSE transport (for production)
    await startHttpServer();
  }
}

main().catch(error => {
  console.error('[x402] Fatal error:', error);
  process.exit(1);
});
`;
}
